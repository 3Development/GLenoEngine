//
// Created by leno on 4/18/23.
//

#ifndef LENOENGINE_VAOVBO_H
#define LENOENGINE_VAOVBO_H
#include "core/gl/enums/glenums.h"
#include <string.h>
#include <vector>
#include <functional>
#include "utilz/math/algebra/objects/vector.h"
#include "GL/glew.h"
#include "GLFW/glfw3.h"

#define UNBOUND_BUFFER 0

/**
 * Buffer for Vao and VaoGroup
 */
 namespace vaoVboDefinitions{

     typedef void* VAO_HANDLE;
     typedef float* ENTITIES_GROUP_DATA;
     typedef std::vector<int>& ENTITIES_GROUP_ACTIVE;
     typedef std::function<void()> DEACTIVATE_FUNCTION;
     typedef std::function<void()> ACTIVATE_FUNCTION;
 }

/**
 * Holds information about one VBO
 * id is the id generated by Opengl
 * attrName is predefined, there should be MACROS or some constants
 *
 * @TODO - change -remove attributeType it is not needed here
 */
struct VBO{
    unsigned int id = 0;
};

/**
 * Holds information about one VAO
 * One VAO can have reference to many VBO's
 * id is id that is generated by Opengl
 * Number at the end signalize how many VBO's can this vao have or how many attributes like position,color,normal
 *
 *
 * NOTE - Because of const unsigned int we have to use alloca -> maybe we should avoid that
 */
struct VAO_5{
    unsigned int id = -1;
    unsigned int indicesId = -1;
    VBO vbos[5];
};

/**
 * VAO group entity. For each vao there could me be multiple objects using the same data from vao buffer.
 * That is why this is called VaoGroup.
 *
 *
 * SlotsPerEntity -> how many floats that one entity need ( p1,p2,p3,n1,n2,n3) Position and normals -> so two components
 * But data that should be contanied in entities data should be DATA ONLY FOR TRANSFORMATION LIKE (Position,Rotation,Scale) Not fixed that like normals, indices. PLUS
 * Position used for moving object not position that is passed to opengl
 */
#pragma pack(1) // To make sure that compiler is not adding wasted bytes to struct. It is called PADDING. with this it will return correct size of struc
template<int NumberOfEntites,int SlotsPerEntity>
struct VaoTransformDataGroup{
    float entitiesData[NumberOfEntites * SlotsPerEntity];
    std::vector<int> active;
    std::vector<int> inactive;
    std::vector<int> availableSlots;
};



/**
 * It generates and buffers the data
 * It also unbinds the buffer with that id
 * @param vao
 * @param data
 * @param sizeofDataInBytes
 * @param targetBuffer
 * @param typeOfData
 * @param attributeType
 * @param indexAttribPointer
 * @param numOfVerticesComponents
 * @param stride
 * @return index -> returning the index that represents position in vao -> array
 */
int initializeVboObjectAndBufferData(VAO_5* vao,
                                      const void* data,
                                      int sizeofDataInBytes ,
                                      GLenum targetBuffer,
                                      GLenum typeOfData,
                                      VboVaoEnums::VboAttributeType attributeType,
                                      int indexAttribPointer,
                                      int numOfVerticesComponents,
                                      float stride
);

/**
 * It generates and buffers the data
 * It also unbinds the buffer with that id
 *
 * Difference between this and method initializeVboObjectAndBufferData is that it will not autmatically search for available
 * index in VAO5 struct array. Instead indexAttribPointer will be used as index
 *
 * If type is GL_ELEMENT_ARRAY_BUFFER, it means it is about INDICES, they will be stored in specif field in VAO_5 and not in array
 *
 *
 * @param vao
 * @param data
 * @param sizeofDataInBytes
 * @param targetBuffer
 * @param typeOfData
 * @param attributeType
 * @param indexAttribPointer
 * @param numOfVerticesComponents
 * @param stride
 */
void initializeVboObjectAndSaveItAtIndexAttrPointer(VAO_5* vao,
                                     const void* data,
                                     int sizeofDataInBytes ,
                                     GLenum targetBuffer,
                                     GLenum typeOfData,
                                     int indexAttribPointer,
                                     int numOfVerticesComponents,
                                     float stride
);

/**
 * Initialize empty vao - array
 * This vao can store up to 5 vbo's or attributes
 * @param vao
 * @param active -> default is set to true
 */
void initializeVao5Object(void* vao,bool active=true);

/**
 * Initialize empty vao - array
 * Plus Vao gets also activated
 * Without memcpy
 * @param dest
 * @param sizeOfVbos -> this params tells us how many of vbo's will there be (how many attributes like position,color,normal)
 */
void initializeVao5Object(VAO_5* vao5,bool active);


/**
 * Prepare model for drawing.
 * Meaning it will activate all of the necessary buffers
 * @param vao
 */
void prepareVaoForDrawing(VAO_5* vao);


/**
 * Drawing element using indices
 * @param indicesCount
 */
void drawVaoUsingIndices(unsigned int indicesCount);

/**
 * Deactivate all the buffers and vao
 * @param vao
 */
void deactivateAndUnbindAllFromVao(VAO_5* vao);

/**
 * Activates vao with id in struct. Meaning when drawing opengl will use that vao
 * @param vao
 */
void activateVao(VAO_5* vao);

/**
 * Deactivates all vao's it sets binding to 0
 * @param vao
 */
void deactivateVao();




/**
 * VAO GROUP FUNCTIONS
 */



/**
 *
 * Returns what would be the size of VaoTransformDataGroup with specifc E and C
 *
 *
 * @tparam NumberOfEntites -> E
 * @tparam NumberOfComponents -> C
 * @tparam initializeVaoGroup
 */
template<int E,int C>
int calculateSizeOfVaoGroup(){
    return ( sizeof(float) * E * C ) + (sizeof(std::vector<int>) * 3);
}

/**
 *
 * @tparam E
 * @tparam C
 * @param group
 */
template<int E,int C>
void initializeVaoGroup(VaoTransformDataGroup<E,C>* instance){

    for(int i = 0; i < E;++i){
        instance->availableSlots.push_back(i);
    }
}


/**
 *
 * @tparam E
 * @tparam C
 * @param vaoTransformDataGroup
 * @return int index slot
 */
template<int E,int C>
int addNewEntity(VaoTransformDataGroup<E,C>* vaoTransformDataGroup){
    if(vaoTransformDataGroup->availableSlots.size() > 0){
        int indexSlot = vaoTransformDataGroup->availableSlots.at(0);

        vaoTransformDataGroup->availableSlots.erase(vaoTransformDataGroup->availableSlots.begin());

        vaoTransformDataGroup->active.push_back(indexSlot);

        return indexSlot;
    }
    throw VboVaoEnums::ErrorCodes::VAOGROUP_NO_MORE_AVAILABLE_SLOTS;
}

/**
 *
/**
 *
 * @tparam E
 * @tparam C -> slots per entity
 * @param vaoTransformDataGroup
 * @param indexOfSlot -> index of starting in big array
 * @param array
 * @param indexStartComponent -> in big array each entity has each own slots, and this index represents at which index this component should be putted
 * @param sizeOfAarray
 */
 template<int E,int C>
 void addComponentDataToEntityArray(VaoTransformDataGroup<E,C>* vaoTransformDataGroup,int indexOfSlot, float* array,float sizeOfAarray,int indexStartComponent){

     for(int i = 0; i < sizeOfAarray;++i){
         vaoTransformDataGroup->entitiesData[(indexOfSlot * C) + indexStartComponent + i] = *(array+i);
     }
 }

/**
 *
 * @tparam E
 * @tparam C
 * @param vaoTransformDataGroup
 * @param indexSlot
 */
template<int E,int C>
void removeEntity(VaoTransformDataGroup<E,C>* vaoTransformDataGroup, int indexSlot){
    auto it = std::find(vaoTransformDataGroup->active.begin(), vaoTransformDataGroup->active.end(), indexSlot);

    if(it != vaoTransformDataGroup->active.end()){
        vaoTransformDataGroup->active.erase(it);

        vaoTransformDataGroup->availableSlots.push_back(indexSlot);
    }else{
        throw VboVaoEnums::ErrorCodes::VAOGROUP_ENTITY_AT_INDEX_NOT_EXISTS;
    }
}

/**
 * Already created object, activate once again
 * @tparam E
 * @tparam C
 * @param vaoTransformDataGroup
 * @param indexSlot
 */
template<int E,int C>
void activateEntity(VaoTransformDataGroup<E,C>* vaoTransformDataGroup, int indexSlot){
    auto it = std::find(vaoTransformDataGroup->inactive.begin(), vaoTransformDataGroup->inactive.end(), indexSlot);

    if(it != vaoTransformDataGroup->active.end()){
        vaoTransformDataGroup->inactive.erase(it);

        vaoTransformDataGroup->active.push_back(indexSlot);
    }else{
        throw VboVaoEnums::ErrorCodes::VAOGROUP_ENTITY_AT_INDEX_NOT_EXISTS;
    }
}

/**
 *
 * @tparam E
 * @tparam C
 * @param vaoTransformDataGroup
 * @param indexSlot
 */
template<int E,int C>
void deactivateEntity(VaoTransformDataGroup<E,C>* vaoTransformDataGroup, int indexSlot){
    auto it = std::find(vaoTransformDataGroup->active.begin(), vaoTransformDataGroup->active.end(), indexSlot);

    if(it != vaoTransformDataGroup->active.end()){
        vaoTransformDataGroup->active.erase(it);

        vaoTransformDataGroup->inactive.push_back(indexSlot);
    }else{
        throw VboVaoEnums::ErrorCodes::VAOGROUP_ENTITY_AT_INDEX_NOT_EXISTS;
    }
}





#endif //LENOENGINE_VAOVBO_H
