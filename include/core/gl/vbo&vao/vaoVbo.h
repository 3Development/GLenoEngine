//
// Created by leno on 4/18/23.
//

#ifndef LENOENGINE_VAOVBO_H
#define LENOENGINE_VAOVBO_H
#include "core/gl/enums/glenums.h"
#include <string.h>
#include <vector>
#include "utilz/math/algebra/objects/vector.h"
#include "GL/glew.h"
#include "GLFW/glfw3.h"

#define UNBOUND_BUFFER 0

/**
 * Buffer for Vao and VaoGroup
 */
typedef void* VAO_HANDLE;
typedef std::vector<float> ENTITIES_GROUP_DATA;
typedef std::vector<float> ENTITIES_GROUP_ACTIVE;

/**
 * Holds information about one VBO
 * id is the id generated by Opengl
 * attrName is predefined, there should be MACROS or some constants
 *
 * @TODO - change -remove attributeType it is not needed here
 */
struct VBO{
    unsigned int id = 0;
};

/**
 * Holds information about one VAO
 * One VAO can have reference to many VBO's
 * id is id that is generated by Opengl
 * Number at the end signalize how many VBO's can this vao have or how many attributes like position,color,normal
 *
 *
 * NOTE - Because of const unsigned int we have to use alloca -> maybe we should avoid that
 */
struct VAO_5{
    unsigned int id = -1;
    unsigned int indicesId = -1;
    VBO vbos[5];
};

/**
 * VAO group entity. For each vao there could me be multiple objects using the same data from vao buffer.
 * That is why this is called VaoGroup.
 *
 *
 */
#pragma pack(1) // To make sure that compiler is not adding wasted bytes to struct. It is called PADDING. with this it will return correct size of struc
template<int NumberOfEntites,int SlotsPerEntity>
struct VAOGroup{
    float entitiesData[NumberOfEntites * SlotsPerEntity];
    std::vector<int> active;
    std::vector<int> inactive;
    std::vector<int> availableSlots;
};



/**
 * It generates and buffers the data
 * It also unbinds the buffer with that id
 * @param vao
 * @param data
 * @param sizeofDataInBytes
 * @param targetBuffer
 * @param typeOfData
 * @param attributeType
 * @param indexAttribPointer
 * @param numOfVerticesComponents
 * @param stride
 * @return index -> returning the index that represents position in vao -> array
 */
int initializeVboObjectAndBufferData(VAO_5* vao,
                                      const void* data,
                                      int sizeofDataInBytes ,
                                      GLenum targetBuffer,
                                      GLenum typeOfData,
                                      VboVaoEnums::VboAttributeType attributeType,
                                      int indexAttribPointer,
                                      int numOfVerticesComponents,
                                      float stride
);

/**
 * It generates and buffers the data
 * It also unbinds the buffer with that id
 *
 * Difference between this and method initializeVboObjectAndBufferData is that it will not autmatically search for available
 * index in VAO5 struct array. Instead indexAttribPointer will be used as index
 *
 * If type is GL_ELEMENT_ARRAY_BUFFER, it means it is about INDICES, they will be stored in specif field in VAO_5 and not in array
 *
 *
 * @param vao
 * @param data
 * @param sizeofDataInBytes
 * @param targetBuffer
 * @param typeOfData
 * @param attributeType
 * @param indexAttribPointer
 * @param numOfVerticesComponents
 * @param stride
 */
void initializeVboObjectAndSaveItAtIndexAttrPointer(VAO_5* vao,
                                     const void* data,
                                     int sizeofDataInBytes ,
                                     GLenum targetBuffer,
                                     GLenum typeOfData,
                                     int indexAttribPointer,
                                     int numOfVerticesComponents,
                                     float stride
);

/**
 * Initialize empty vao - array
 * This vao can store up to 5 vbo's or attributes
 * @param vao
 * @param active -> default is set to true
 */
void initializeVao5Object(void* vao,bool active=true);


/**
 * Prepare model for drawing.
 * Meaning it will activate all of the necessary buffers
 * @param vao
 */
void prepareVaoForDrawing(VAO_5* vao);


/**
 * Drawing element using indices
 * @param indicesCount
 */
void drawVaoUsingIndices(unsigned int indicesCount);

/**
 * Deactivate all the buffers and vao
 * @param vao
 */
void deactivateAndUnbindAllFromVao(VAO_5* vao);

/**
 * Activates vao with id in struct. Meaning when drawing opengl will use that vao
 * @param vao
 */
void activateVao(VAO_5* vao);

/**
 * Deactivates all vao's it sets binding to 0
 * @param vao
 */
void deactivateVao();




/**
 * VAO GROUP FUNCTIONS
 */



/**
 *
 * Returns what would be the size of VAOGroup with specifc E and C
 *
 *
 * @tparam NumberOfEntites -> E
 * @tparam NumberOfComponents -> C
 * @tparam initializeVaoGroup
 */
template<int E,int C>
int calculateSizeOfVaoGroup(){
    return ( sizeof(float) * E * C ) + (sizeof(std::vector<int>) * 3);
}

/**
 *
 * @tparam E
 * @tparam C
 * @param group
 */
template<int E,int C>
void initializeVaoGroup(VAOGroup<E,C>* instance){

    for(int i = 0; i < E;++i){
        instance->availableSlots.push_back(i);
    }
}


/**
 *
 * @tparam E
 * @tparam C
 * @param vaoGroup
 * @return int index slot
 */
template<int E,int C>
int addNewEntity(VAOGroup<E,C>* vaoGroup){
    if(vaoGroup->availableSlots.size() > 0){
        int indexSlot = vaoGroup->availableSlots.at(0);

        vaoGroup->availableSlots.erase(vaoGroup->availableSlots.begin());

        vaoGroup->active.push_back(indexSlot);

        return indexSlot;
    }
    throw VboVaoEnums::ErrorCodes::VAOGROUP_NO_MORE_AVAILABLE_SLOTS;
}

/**
 *
 * @tparam E
 * @tparam C
 * @param vaoGroup
 * @param indexSlot
 */
template<int E,int C>
void removeEntity(VAOGroup<E,C>* vaoGroup,int indexSlot){
    auto it = std::find(vaoGroup->active.begin(),vaoGroup->active.end(),indexSlot);

    if(it != vaoGroup->active.end()){
        vaoGroup->active.erase(it);

        vaoGroup->availableSlots.push_back(indexSlot);
    }else{
        throw VboVaoEnums::ErrorCodes::VAOGROUP_ENTITY_AT_INDEX_NOT_EXISTS;
    }
}

/**
 *
 * @tparam E
 * @tparam C
 * @param vaoGroup
 * @param indexSlot
 */
template<int E,int C>
void deactivateEntity(VAOGroup<E,C>* vaoGroup,int indexSlot){
    auto it = std::find(vaoGroup->active.begin(),vaoGroup->active.end(),indexSlot);

    if(it != vaoGroup->active.end()){
        vaoGroup->active.erase(it);

        vaoGroup->inactive.push_back(indexSlot);
    }else{
        throw VboVaoEnums::ErrorCodes::VAOGROUP_ENTITY_AT_INDEX_NOT_EXISTS;
    }
}

#endif //LENOENGINE_VAOVBO_H
